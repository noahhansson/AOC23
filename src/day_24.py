from utils import read_input
from typing import TypeAlias
from itertools import combinations, product
from math import copysign

TraceType: TypeAlias = tuple[tuple[int, int, int], tuple[int, int, int]]


def parse_input() -> list[TraceType]:
    inpt = read_input("24")

    traces: list[TraceType] = []

    for row in inpt:
        pos = tuple([int(x.strip()) for x in row.split("@")[0].split(",")])
        vel = tuple([int(x.strip()) for x in row.split("@")[1].split(",")])
        traces.append((pos, vel))

    return traces


def calc_intersect_p1(t1: TraceType, t2: TraceType) -> tuple[float, float] | None:
    x1 = t1[0][0]
    x2 = t1[0][0] + t1[1][0]
    x3 = t2[0][0]
    x4 = t2[0][0] + t2[1][0]

    y1 = t1[0][1]
    y2 = t1[0][1] + t1[1][1]
    y3 = t2[0][1]
    y4 = t2[0][1] + t2[1][1]

    try:
        det_x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / (
            (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
        )
        det_y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / (
            (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
        )
    except ZeroDivisionError:
        return None

    if copysign(1, (det_x - x1)) == copysign(1, t1[1][0]) and copysign(
        1, (det_x - x3)
    ) == copysign(1, t2[1][0]):
        # Check sign of velocity to ensure that the collision is in the future
        return det_x, det_y

    return None


def calc_intersect(t1, t2):
    """Code generated by ChatGPT since I can't bother with linear algebra"""

    def _cross_product(v1, v2):
        return (
            v1[1] * v2[2] - v1[2] * v2[1],
            v1[2] * v2[0] - v1[0] * v2[2],
            v1[0] * v2[1] - v1[1] * v2[0],
        )

    def _subtract_vectors(v1, v2):
        return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]]

    def _find_line_intersection(
        line1_point, line1_direction, line2_point, line2_direction
    ):
        # Check if the direction vectors of the lines are parallel
        cross_product_result = _cross_product(line1_direction, line2_direction)
        if all(coord == 0 for coord in cross_product_result):
            return None

        # Calculate the parameter values for the point of intersection
        t1_num = _cross_product(
            _subtract_vectors(line2_point, line1_point), line2_direction
        )
        t_denom = _cross_product(line1_direction, line2_direction)

        if any([x == 0 for x in t_denom]):
            return None

        t1 = t1_num[0] / t_denom[0]

        # Calculate the point of intersection
        intersection_point = [
            line1_point[0] + t1 * line1_direction[0],
            line1_point[1] + t1 * line1_direction[1],
            line1_point[2] + t1 * line1_direction[2],
        ]

        return intersection_point

    return _find_line_intersection(t1[0], t1[1], t2[0], t2[1])


def get_first_solution():
    traces = parse_input()

    n_collisions = 0

    for t1, t2 in combinations(traces, 2):
        if intersection := calc_intersect_p1(t1, t2):
            if (
                intersection[0] <= 400000000000000
                and intersection[0] >= 200000000000000
                and intersection[1] <= 400000000000000
                and intersection[1] >= 200000000000000
            ):
                n_collisions += 1

    return n_collisions


def get_second_solution():
    traces = parse_input()

    smallest_error = ((-1, -1, -1), 10**1000)
    intersection_mean = {}
    intersection_distance = {}

    # Brute force these values with finer step size
    for dx, dy, dz in product(
        range(-6, -4, 1), 
        range(-251, -249, 1), 
        range(216, 218, 1)
    ):
        traces_relative = []

        for trace in traces:
            vel_relative = tuple([a - da for a, da in zip(trace[1], [dx, dy, dz])])

            traces_relative.append((trace[0], vel_relative))

        intersections = []

        for t1, t2 in zip(traces_relative[:-1], traces_relative[1:]):
            intersection_point = calc_intersect(t1, t2)
            intersections.append(intersection_point)

        if not all(intersections):
            # Some lines are parallel relative throw direction
            # Therefore there is no feasible soultion
            continue

        # Due to float overflow this calculation is not entirely accurate
        intersection_mean[(dx, dy, dz)] = [
            sum([p[0] for p in intersections]) / len(intersections),
            sum([p[1] for p in intersections]) / len(intersections),
            sum([p[2] for p in intersections]) / len(intersections),
        ]
        intersection_distance[(dx, dy, dz)] = [
            sum([
                    (p[0] - intersection_mean[(dx, dy, dz)][0]) ** 2
                    for p in intersections
                ]),
            sum([
                    (p[1] - intersection_mean[(dx, dy, dz)][1]) ** 2
                    for p in intersections
                ]),
            sum([
                    (p[2] - intersection_mean[(dx, dy, dz)][2]) ** 2
                    for p in intersections
                ]),
        ]
        total_error = sum(intersection_distance[(dx, dy, dz)]) ** (1 / 2)

        if total_error <= smallest_error[1]:
            smallest_error = ((dx, dy, dz), total_error)
            print(smallest_error)

            # Check if all intersections are the same
            if (sum([
                        len(set([p[0] for p in intersections])),
                        len(set([p[0] for p in intersections])),
                        len(set([p[0] for p in intersections])),
                    ])== 3):
                print(f"Using velocity ({dx}, {dy}, {dz}) all traces intersect at {intersections[0]}")
                return sum([int(x) for x in intersections[0]])

    if not smallest_error[1] == 0:
        raise ValueError("Could not find an intersection point")


print(get_first_solution())
print(get_second_solution())
